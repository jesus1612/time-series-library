"""
High-level AR model interface

Provides a user-friendly API for AR modeling with automatic order selection,
comprehensive diagnostics, and easy-to-use methods following scikit-learn conventions.
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from typing import Union, Optional, Dict, Any, Tuple
from ..core.base import TimeSeriesModel
from ..core.arima import ARProcess
from ..core.acf_pacf import ACFPACFAnalyzer
from ..core.stationarity import StationarityAnalyzer
from ..preprocessing.validation import DataValidator, DataQualityReport
from ..metrics.evaluation import ModelEvaluator
from .selection import AROrderSelector


class ARModel(TimeSeriesModel):
    """
    High-level AR model with automatic order selection and comprehensive diagnostics
    
    Autoregressive (AR) models are suitable for stationary time series where
    the current value depends on previous values. The model automatically
    identifies the optimal order using PACF analysis.
    
    The AR(p) model is defined as:
        y_t = c + φ₁y_{t-1} + φ₂y_{t-2} + ... + φₚy_{t-p} + ε_t
    
    where ε_t is white noise and φ₁, ..., φₚ are the AR parameters.
    """
    
    def __init__(self,
                 order: Optional[int] = None,
                 trend: str = 'c',
                 auto_select: bool = True,
                 max_order: int = 5,
                 selection_method: str = 'pacf',
                 validation: bool = True):
        """
        Initialize AR model
        
        Parameters:
        -----------
        order : int, optional
            AR order (p). If None and auto_select=True, will be determined automatically
        trend : str
            'c' (constant/intercept), 'nc' (no constant)
        auto_select : bool
            Whether to automatically select optimal order using PACF
        max_order : int
            Maximum order to consider for automatic selection
        selection_method : str
            Method for order selection: 'pacf' (PACF cutoff) or 'aic' (information criterion)
        validation : bool
            Whether to validate input data
        """
        super().__init__()
        self.order = order
        self.trend = trend
        self.auto_select = auto_select
        self.max_order = max_order
        self.selection_method = selection_method
        self.validation = validation
        
        # Initialize components
        self._ar_process = None
        self._data_validator = DataValidator() if validation else None
        self._model_evaluator = ModelEvaluator()
        self._acf_pacf_analyzer = ACFPACFAnalyzer()
        self._stationarity_analyzer = StationarityAnalyzer()
        self._order_selector = AROrderSelector(max_order, method=selection_method)
        
        # Store analysis results
        self._acf_pacf_results = None
        self._stationarity_results = None
        self._order_selection_results = None
        self._data_quality_report = None
    
    def fit(self, data: Union[np.ndarray, pd.Series, list], **kwargs) -> 'ARModel':
        """
        Fit AR model to data
        
        Parameters:
        -----------
        data : array-like
            Time series data (should be stationary or will be checked)
        **kwargs
            Additional fitting parameters
            
        Returns:
        --------
        self : ARModel
            Fitted model
        """
        # Convert to numpy array
        if isinstance(data, pd.Series):
            data = data.values
        else:
            data = np.asarray(data, dtype=float)
        
        # Validate data if requested
        if self.validation and self._data_validator:
            validation_results = self._data_validator.validate(data)
            if not validation_results['is_valid']:
                raise ValueError(f"Data validation failed: {validation_results['issues']}")
            
            # Generate data quality report
            quality_report = DataQualityReport(self._data_validator)
            self._data_quality_report = quality_report.generate_report(data)
        
        # Store original data
        self._data = data
        
        # Perform exploratory analysis
        self._perform_exploratory_analysis(data)
        
        # Check stationarity
        if not self._stationarity_results['is_stationary']:
            import warnings
            warnings.warn(
                "Data appears to be non-stationary. AR models require stationary data. "
                "Consider differencing the data first or using ARIMA model instead.",
                UserWarning
            )
        
        # Determine model order
        if self.auto_select or self.order is None:
            self.order = self._order_selector.select(data)
            self._order_selection_results = self._order_selector.selection_results
            
            if self.order == 0:
                # Default to AR(1) if selection gives 0
                self.order = 1
        
        # Fit the AR model
        self._ar_process = ARProcess(
            order=self.order,
            trend=self.trend,
            n_jobs=1  # Linear implementation
        )
        
        self._ar_process.fit(data, **kwargs)
        
        # Store fitted parameters
        self._fitted_params = self._ar_process._fitted_params
        self._fitted = True
        
        return self
    
    def predict(self, 
                steps: int = 1, 
                return_conf_int: bool = False,
                alpha: float = 0.05,
                **kwargs) -> Union[np.ndarray, Tuple[np.ndarray, Tuple[np.ndarray, np.ndarray]]]:
        """
        Generate predictions from the fitted model
        
        Parameters:
        -----------
        steps : int
            Number of steps ahead to predict
        return_conf_int : bool
            Whether to return confidence intervals
        alpha : float
            Significance level for confidence intervals (default: 0.05 for 95% CI)
        **kwargs
            Additional prediction parameters
            
        Returns:
        --------
        predictions : np.ndarray
            Predicted values
        conf_int : tuple, optional
            Confidence intervals (lower, upper) if return_conf_int=True
        """
        self._validate_fitted()
        
        if return_conf_int:
            predictions, conf_int = self._ar_process.predict(steps, return_conf_int=True, **kwargs)
            return predictions, conf_int
        else:
            return self._ar_process.predict(steps, return_conf_int=False, **kwargs)
    
    def get_residuals(self) -> np.ndarray:
        """Get model residuals"""
        self._validate_fitted()
        return self._ar_process.get_residuals()
    
    def get_fitted_values(self) -> np.ndarray:
        """Get fitted values"""
        self._validate_fitted()
        return self._ar_process.get_fitted_values()
    
    def summary(self) -> str:
        """Generate comprehensive model summary"""
        self._validate_fitted()
        
        summary = "AR Model Summary\n"
        summary += "=" * 60 + "\n\n"
        
        # Model information
        summary += f"Model: AR({self.order})\n"
        summary += f"Trend: {self.trend}\n"
        summary += f"Auto-selection: {self.auto_select}\n"
        if self.auto_select:
            summary += f"Selection method: {self.selection_method}\n"
        summary += "\n"
        
        # Data information
        summary += f"Data Information:\n"
        summary += f"  Length: {len(self._data)}\n"
        summary += f"  Mean: {np.mean(self._data):.6f}\n"
        summary += f"  Std: {np.std(self._data):.6f}\n\n"
        
        # Model parameters
        if self._fitted_params:
            summary += "Model Parameters:\n"
            for param_name, param_value in self._fitted_params['parameters'].items():
                summary += f"  {param_name}: {param_value:.6f}\n"
            summary += "\n"
        
        # Model statistics
        if self._fitted_params:
            summary += "Model Statistics:\n"
            summary += f"  Log-Likelihood: {self._fitted_params['log_likelihood']:.6f}\n"
            summary += f"  AIC: {self._fitted_params['aic']:.6f}\n"
            summary += f"  BIC: {self._fitted_params['bic']:.6f}\n\n"
        
        # Add PACF analysis results
        if self._acf_pacf_results:
            summary += "PACF Analysis:\n"
            suggested = self._acf_pacf_results['suggested_orders']
            summary += f"  Suggested p: {suggested['suggested_p']}\n"
            summary += f"  (PACF cutoff indicates AR order)\n\n"
        
        # Stationarity analysis
        if self._stationarity_results:
            summary += "Stationarity Analysis:\n"
            summary += f"  Is Stationary: {self._stationarity_results['is_stationary']}\n"
            if not self._stationarity_results['is_stationary']:
                summary += f"  Warning: AR requires stationary data!\n"
            summary += "\n"
        
        return summary
    
    def plot_diagnostics(self, figsize: Tuple[int, int] = (12, 8)):
        """
        Plot diagnostic plots for the model
        
        Parameters:
        -----------
        figsize : tuple
            Figure size
        """
        self._validate_fitted()
        
        fig, axes = plt.subplots(2, 2, figsize=figsize)
        fig.suptitle(f'AR({self.order}) Model Diagnostics', fontsize=16)
        
        # Get residuals and fitted values
        residuals = self.get_residuals()
        fitted_values = self.get_fitted_values()
        
        # 1. Residuals vs Time
        axes[0, 0].plot(residuals)
        axes[0, 0].set_title('Residuals vs Time')
        axes[0, 0].set_xlabel('Time')
        axes[0, 0].set_ylabel('Residuals')
        axes[0, 0].axhline(y=0, color='r', linestyle='--')
        axes[0, 0].grid(True, alpha=0.3)
        
        # 2. Residuals vs Fitted Values
        axes[0, 1].scatter(fitted_values, residuals, alpha=0.6)
        axes[0, 1].set_title('Residuals vs Fitted Values')
        axes[0, 1].set_xlabel('Fitted Values')
        axes[0, 1].set_ylabel('Residuals')
        axes[0, 1].axhline(y=0, color='r', linestyle='--')
        axes[0, 1].grid(True, alpha=0.3)
        
        # 3. Q-Q Plot
        from scipy import stats
        stats.probplot(residuals, dist="norm", plot=axes[1, 0])
        axes[1, 0].set_title('Q-Q Plot')
        axes[1, 0].grid(True, alpha=0.3)
        
        # 4. PACF Plot (for model identification)
        if self._acf_pacf_results:
            pacf_values = self._acf_pacf_results['pacf_values']
            lags = self._acf_pacf_results['pacf_lags']
            
            axes[1, 1].bar(lags, pacf_values, width=0.8)
            axes[1, 1].set_title('PACF (Model Identification)')
            axes[1, 1].set_xlabel('Lag')
            axes[1, 1].set_ylabel('PACF')
            axes[1, 1].axhline(y=0, color='k', linestyle='-')
            
            # Add confidence bounds
            n = len(self._data)
            conf_bound = 1.96 / np.sqrt(n)
            axes[1, 1].axhline(y=conf_bound, color='r', linestyle='--', alpha=0.7, label='95% CI')
            axes[1, 1].axhline(y=-conf_bound, color='r', linestyle='--', alpha=0.7)
            axes[1, 1].axvline(x=self.order, color='g', linestyle=':', linewidth=2, label=f'Selected order: {self.order}')
            axes[1, 1].legend()
            axes[1, 1].grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.show()
    
    def plot_forecast(self, 
                     steps: int = 10, 
                     figsize: Tuple[int, int] = (12, 6),
                     include_data: bool = True):
        """
        Plot forecast with confidence intervals
        
        Parameters:
        -----------
        steps : int
            Number of steps to forecast
        figsize : tuple
            Figure size
        include_data : bool
            Whether to include historical data in the plot
        """
        self._validate_fitted()
        
        # Generate forecast
        forecast, conf_int = self.predict(steps, return_conf_int=True)
        
        plt.figure(figsize=figsize)
        
        # Plot historical data
        if include_data:
            plt.plot(self._data, label='Historical Data', color='blue')
        
        # Plot forecast
        forecast_index = np.arange(len(self._data), len(self._data) + steps)
        plt.plot(forecast_index, forecast, label='Forecast', color='red', linewidth=2)
        
        # Plot confidence intervals
        plt.fill_between(forecast_index, conf_int[0], conf_int[1], 
                        alpha=0.3, color='red', label='95% Confidence Interval')
        
        plt.title(f'AR({self.order}) Forecast')
        plt.xlabel('Time')
        plt.ylabel('Value')
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.show()
    
    def _perform_exploratory_analysis(self, data: np.ndarray):
        """Perform exploratory data analysis"""
        # ACF/PACF analysis
        self._acf_pacf_results = self._acf_pacf_analyzer.analyze(data)
        
        # Stationarity analysis
        self._stationarity_results = self._stationarity_analyzer.analyze(data)
    
    def get_order_selection_results(self) -> Optional[Dict[str, Any]]:
        """Get order selection results"""
        return self._order_selection_results
    
    def get_exploratory_analysis(self) -> Dict[str, Any]:
        """Get exploratory analysis results"""
        return {
            'acf_pacf': self._acf_pacf_results,
            'stationarity': self._stationarity_results,
            'data_quality': self._data_quality_report,
            'order_selection': self._order_selection_results
        }
    
    def evaluate_forecast(self, 
                         actual: np.ndarray, 
                         predicted: np.ndarray) -> Dict[str, float]:
        """
        Evaluate forecast accuracy
        
        Parameters:
        -----------
        actual : np.ndarray
            Actual values
        predicted : np.ndarray
            Predicted values
            
        Returns:
        --------
        metrics : dict
            Forecast evaluation metrics
        """
        evaluation = self._model_evaluator.evaluate_model(
            self._fitted_params,
            actual=actual,
            predicted=predicted
        )
        
        return evaluation['forecast_metrics']
    
    def get_residual_diagnostics(self) -> Dict[str, Any]:
        """Get comprehensive residual diagnostics"""
        self._validate_fitted()
        
        residuals = self.get_residuals()
        fitted_values = self.get_fitted_values()
        
        evaluation = self._model_evaluator.evaluate_model(
            self._fitted_params,
            residuals=residuals,
            fitted_values=fitted_values
        )
        
        return evaluation['residual_analysis']

